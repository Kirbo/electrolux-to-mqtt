stages:
  - init
  - test
  - build
  - release
  - docs

workflow:
  rules:
    # Run pipeline for merge requests
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
    # Run pipeline for pushes to default branch
    - if: '$CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH'
    # Run pipeline for pushes to branches without open merge requests
    - if: '$CI_COMMIT_BRANCH && $CI_OPEN_MERGE_REQUESTS'
      when: never
    # Run pipeline for all other branch pushes
    - if: '$CI_COMMIT_BRANCH'
    # Run pipeline for web/api triggers
    - if: '$CI_PIPELINE_SOURCE == "web"'

variables:
  DOCKER_REGISTRY: ${CI_REGISTRY}
  DOCKERHUB_PASSWORD: ${CI_REGISTRY_PASSWORD}
  DOCKERHUB_PASSWORD_READ: ${CI_REGISTRY_PASSWORD_READ}
  DOCKERHUB_REPOSITORY: kirbownz/electrolux-to-mqtt
  DOCKERHUB_USERNAME: ${CI_REGISTRY_USERNAME}
  README_FILEPATH: ${CI_PROJECT_DIR}/README.md
  SONAR_USER_HOME: "${CI_PROJECT_DIR}/.sonar"  # Defines the location of the analysis task cache
  GIT_DEPTH: "0"  # Tells git to fetch all the branches of the project, required by the analysis task
  GIT_STRATEGY: fetch
  GITLAB_TOKEN: ${CI_JOB_TOKEN}

# Default configuration for all jobs
default:
  # Prefer private runner (macos tag), fallback to shared runners if unavailable
  # Jobs without the macos tag will use shared runners automatically
  tags:
    - macos

initialise variables:
  stage: init
  image: alpine:latest
  interruptible: true
  rules:
    - if: '$CI_COMMIT_TAG == null'
      changes:
        - .gitlab-ci.yml
        - docker-compose*.yml
        - Dockerfile
        - entrypoint.sh
        - package.json
        - pnpm-lock.yaml
        - src/**/*
        - tests/**/*
        - tsconfig.json
        - vitest.config.ts
        - vitest.setup.ts
      when: always
    - when: never
  cache: []
  artifacts:
    reports:
      dotenv: variables.env
  script:
    - touch variables.env
    - echo "NODE_VERSION=$(cat .nvmrc)-alpine3.23" >> variables.env

bump version:
  stage: init
  image:
    name: registry.gitlab.com/go-semantic-release/semantic-release:latest
    entrypoint: [""]
  interruptible: true
  rules:
    - if: '$CI_COMMIT_TAG == null'
      changes:
        - .gitlab-ci.yml
        - docker-compose*.yml
        - Dockerfile
        - entrypoint.sh
        - package.json
        - pnpm-lock.yaml
        - src/**/*
        - tests/**/*
        - tsconfig.json
        - vitest.config.ts
        - vitest.setup.ts
      when: always
    - when: never
  cache: []
  artifacts:
    paths:
      - .version-unreleased
      - build.env
      - CHANGELOG.md
      - sonar-project.properties
    expire_in: never
  before_script:
    - git config --global --add safe.directory "$CI_PROJECT_DIR"
    - git remote set-url origin "$CI_REPOSITORY_URL" || echo 'Not a git repository; skipping'
    - git fetch --tags --force || true
    - git fetch origin "$CI_DEFAULT_BRANCH" || true
  script:
    - semantic-release --version-file --allow-no-changes --changelog CHANGELOG.md --dry
    - export VERSION=$(cat .version-unreleased)
    - echo "VERSION=${VERSION}" > build.env
    - echo "sonar.projectVersion=${VERSION}" >> sonar-project.properties
    - cat CHANGELOG.md

install dependencies:
  stage: init
  image: node:${NODE_VERSION}
  interruptible: true
  rules:
    - if: '$CI_COMMIT_TAG == null'
      changes:
        - .gitlab-ci.yml
        - biome.jsonc
        - package.json
        - pnpm-lock.yaml
        - src/**/*
        - tests/**/*
        - tsconfig.json
        - vitest.config.ts
        - vitest.setup.ts
      when: always
    - when: never
  cache:
    key:
      prefix: ${CI_COMMIT_REF_SLUG}
      files:
        - pnpm-lock.yaml
    paths:
      - .pnpm-store
      - node_modules
    policy: push
  needs:
    - job: initialise variables
      artifacts: true
  before_script:
    - echo "Node version from .nvmrc:" && cat .nvmrc
    - node --version
    - npm --version
    - export PACKAGE_MANAGER=$(node -p "require('./package.json').packageManager")
    - export PACKAGE_MANAGER_NAME=$(echo ${PACKAGE_MANAGER} | cut -d'@' -f1)
    - export PACKAGE_MANAGER_VERSION=$(echo ${PACKAGE_MANAGER} | cut -d'@' -f2)
    - echo "Package manager:" ${PACKAGE_MANAGER_NAME}@${PACKAGE_MANAGER_VERSION}
    - |
      if [ "${PACKAGE_MANAGER_NAME}" != "npm" ]; then
        echo "Installing package manager ${PACKAGE_MANAGER_NAME}@${PACKAGE_MANAGER_VERSION}"
        npm install -g --force ${PACKAGE_MANAGER_NAME}@${PACKAGE_MANAGER_VERSION}
      fi
    - |
      if [ "${PACKAGE_MANAGER_NAME}" = "pnpm" ]; then
        pnpm config set store-dir .pnpm-store
      fi
  script:
    - echo "Installing dependencies..."
    - ${PACKAGE_MANAGER_NAME} install --config.scripts-prepend-node-path=true

test:
  stage: test
  image: node:${NODE_VERSION}
  interruptible: true
  rules:
    - if: '$CI_COMMIT_TAG == null'
      changes:
        - .gitlab-ci.yml
        - biome.jsonc
        - package.json
        - pnpm-lock.yaml
        - src/**/*
        - tests/**/*
        - tsconfig.json
        - vitest.config.ts
        - vitest.setup.ts
      when: always
    - when: never
  cache:
    key:
      prefix: ${CI_COMMIT_REF_SLUG}
      files:
        - pnpm-lock.yaml
    paths:
      - .pnpm-store
      - node_modules
    policy: pull
  needs:
    - job: initialise variables
      artifacts: true
    - job: install dependencies
      artifacts: false
  coverage: '/All files(?:\s*\x1b\[[0-9;]*m)?\s*\|(?:\s*\x1b\[[0-9;]*m)?\s*[0-9.]+(?:\s*\x1b\[[0-9;]*m)?\s*\|(?:\s*\x1b\[[0-9;]*m)?\s*[0-9.]+(?:\s*\x1b\[[0-9;]*m)?\s*\|(?:\s*\x1b\[[0-9;]*m)?\s*[0-9.]+(?:\s*\x1b\[[0-9;]*m)?\s*\|(?:\s*\x1b\[[0-9;]*m)?\s*([0-9.]+)/'
  artifacts:
    reports:
      coverage_report:
        coverage_format: cobertura
        path: coverage/cobertura-coverage.xml
    paths:
      - coverage/
    expire_in: 1 week
  before_script:
    - echo "Running tests with coverage..."
    - export PACKAGE_MANAGER=$(node -p "require('./package.json').packageManager")
    - export PACKAGE_MANAGER_NAME=$(echo ${PACKAGE_MANAGER} | cut -d'@' -f1)
    - export PACKAGE_MANAGER_VERSION=$(echo ${PACKAGE_MANAGER} | cut -d'@' -f2)
    - |
      if [ "${PACKAGE_MANAGER_NAME}" != "npm" ]; then
        npm install -g --force ${PACKAGE_MANAGER_NAME}@${PACKAGE_MANAGER_VERSION}
      fi
    - |
      if [ "${PACKAGE_MANAGER_NAME}" = "pnpm" ]; then
        pnpm config set store-dir .pnpm-store
      fi
  script:
    - FORCE_COLOR=1 ${PACKAGE_MANAGER_NAME} test
  allow_failure: false

lint:
  stage: test
  image: node:${NODE_VERSION}
  interruptible: true
  rules:
    - if: '$CI_COMMIT_TAG == null'
      changes:
        - .gitlab-ci.yml
        - biome.jsonc
        - package.json
        - pnpm-lock.yaml
        - src/**/*
        - tests/**/*
        - tsconfig.json
        - vitest.config.ts
        - vitest.setup.ts
      when: always
    - when: never
  cache:
    key:
      prefix: ${CI_COMMIT_REF_SLUG}
      files:
        - pnpm-lock.yaml
    paths:
      - .pnpm-store
      - node_modules
    policy: pull
  needs:
    - job: initialise variables
      artifacts: true
    - job: install dependencies
      artifacts: false
  before_script:
    - echo "Running linter checks..."
    - export PACKAGE_MANAGER=$(node -p "require('./package.json').packageManager")
    - export PACKAGE_MANAGER_NAME=$(echo ${PACKAGE_MANAGER} | cut -d'@' -f1)
    - export PACKAGE_MANAGER_VERSION=$(echo ${PACKAGE_MANAGER} | cut -d'@' -f2)
    - |
      if [ "${PACKAGE_MANAGER_NAME}" != "npm" ]; then
        npm install -g --force ${PACKAGE_MANAGER_NAME}@${PACKAGE_MANAGER_VERSION}
      fi
    - |
      if [ "${PACKAGE_MANAGER_NAME}" = "pnpm" ]; then
        pnpm config set store-dir .pnpm-store
      fi
  script:
    - ${PACKAGE_MANAGER_NAME} biome check .
  allow_failure: false

audit:
  stage: test
  image: node:${NODE_VERSION}
  interruptible: true
  rules:
    - if: '$CI_COMMIT_TAG == null'
      changes:
        - .gitlab-ci.yml
        - package.json
        - pnpm-lock.yaml
      when: always
    - when: never
  cache:
    key:
      prefix: ${CI_COMMIT_REF_SLUG}
      files:
        - pnpm-lock.yaml
    paths:
      - .pnpm-store
      - node_modules
    policy: pull
  needs:
    - job: initialise variables
      artifacts: true
    - job: install dependencies
      artifacts: false
  before_script:
    - echo "Running security audit..."
    - export PACKAGE_MANAGER=$(node -p "require('./package.json').packageManager")
    - export PACKAGE_MANAGER_NAME=$(echo ${PACKAGE_MANAGER} | cut -d'@' -f1)
    - export PACKAGE_MANAGER_VERSION=$(echo ${PACKAGE_MANAGER} | cut -d'@' -f2)
    - |
      if [ "${PACKAGE_MANAGER_NAME}" != "npm" ]; then
        npm install -g --force ${PACKAGE_MANAGER_NAME}@${PACKAGE_MANAGER_VERSION}
      fi
    - |
      if [ "${PACKAGE_MANAGER_NAME}" = "pnpm" ]; then
        pnpm config set store-dir .pnpm-store
      fi
  script:
    - ${PACKAGE_MANAGER_NAME} audit
  allow_failure: false

sonarcloud-check:
  stage: test
  rules:
    - if: '$CI_COMMIT_TAG == null'
      changes:
        - .gitlab-ci.yml
        - biome.jsonc
        - package.json
        - pnpm-lock.yaml
        - src/**/*
        - tests/**/*
        - tsconfig.json
        - vitest.config.ts
        - vitest.setup.ts
      when: always
    - when: never
  image:
    name: sonarsource/sonar-scanner-cli:latest
    entrypoint: [""]
  cache:
    key: "${CI_JOB_NAME}"
    paths:
      - .sonar/cache
  needs:
    - job: bump version
      artifacts: true
    - job: install dependencies
      artifacts: false
    - job: test
      artifacts: true
  before_script:
    - test -f coverage/lcov.info && echo "LCOV report found" || echo "LCOV report NOT found"
    - test -f coverage/cobertura-coverage.xml && echo "Cobertura report found" || echo "Cobertura report NOT found"
  script:
    - sonar-scanner

try to build docker images:
  stage: build
  image: docker:latest
  interruptible: true
  rules:
    - if: '$CI_COMMIT_TAG == null && $CI_COMMIT_BRANCH != "main"'
      changes:
        - .gitlab-ci.yml
        - docker/Dockerfile
        - entrypoint.sh
        - package.json
        - pnpm-lock.yaml
        - src/**/*
        - tsconfig.json
      when: always
    - when: never
  cache: []
  needs:
    - job: initialise variables
      artifacts: true
    - job: bump version
      artifacts: true
  services:
    - docker:dind
  variables:
    DOCKER_TLS_CERTDIR: ""
  before_script:
    - apk add --no-cache qemu qemu-system-x86_64
    # Try local Docker socket first, fall back to dind
    - |
      export DOCKER_HOST=unix:///var/run/docker.sock
      if docker info >/dev/null 2>&1; then
        echo "Using local Docker socket (Mac runner)"
      else
        export DOCKER_HOST=tcp://docker:2375
        echo "Using Docker-in-Docker service (shared runner)"
      fi
    - echo "${DOCKERHUB_PASSWORD_READ}" | docker login -u "${DOCKERHUB_USERNAME}" --password-stdin "${DOCKER_REGISTRY}"
    - echo "${DOCKERHUB_PASSWORD_READ}" | docker login -u "${DOCKERHUB_USERNAME}" --password-stdin dhi.io
  script:
    - source build.env
    - docker buildx create --driver docker-container --use || docker buildx use default
    - docker buildx build --build-arg NODE_VERSION=${NODE_VERSION} --build-arg VERSION=${VERSION} --platform linux/amd64,linux/arm64 -t kirbownz/electrolux-to-mqtt:latest -f docker/Dockerfile .

create gitlab release:
  stage: release
  image:
    name: registry.gitlab.com/go-semantic-release/semantic-release:latest
    entrypoint: [""]
  interruptible: true
  rules:
    - if: '$CI_COMMIT_TAG == null && $CI_COMMIT_BRANCH == "main"'
      changes:
        - .gitlab-ci.yml
        - docker/Dockerfile
        - entrypoint.sh
        - package.json
        - pnpm-lock.yaml
        - src/**/*
        - tsconfig.json
      when: always
    - when: never
  cache: []
  needs:
    - job: initialise variables
      artifacts: false
    - job: bump version
      artifacts: true
  before_script:
    - git config --global --add safe.directory "$CI_PROJECT_DIR"
    - git remote set-url origin "$CI_REPOSITORY_URL" || echo 'Not a git repository; skipping'
    - git fetch --tags --force || true
    - git fetch origin "$CI_DEFAULT_BRANCH" || true
  script:
    - semantic-release

build and deploy docker images:
  stage: release
  image: docker:latest
  interruptible: true
  rules:
    - if: '$CI_COMMIT_TAG == null && $CI_COMMIT_BRANCH == "main"'
      changes:
        - .gitlab-ci.yml
        - docker/Dockerfile
        - entrypoint.sh
        - package.json
        - pnpm-lock.yaml
        - src/**/*
        - tsconfig.json
      when: always
    - when: never
  cache: []
  needs:
    - job: initialise variables
      artifacts: true
    - job: bump version
      artifacts: true
  services:
    - docker:dind
  variables:
    DOCKER_TLS_CERTDIR: ""
  before_script:
    - apk add --no-cache qemu qemu-system-x86_64
    # Try local Docker socket first, fall back to dind
    - |
      export DOCKER_HOST=unix:///var/run/docker.sock
      if docker info >/dev/null 2>&1; then
        echo "Using local Docker socket (Mac runner)"
      else
        export DOCKER_HOST=tcp://docker:2375
        echo "Using Docker-in-Docker service (shared runner)"
      fi
    - echo "${DOCKERHUB_PASSWORD}" | docker login -u "${DOCKERHUB_USERNAME}" --password-stdin "${DOCKER_REGISTRY}"
    - echo "${DOCKERHUB_PASSWORD}" | docker login -u "${DOCKERHUB_USERNAME}" --password-stdin dhi.io
  script:
    - source build.env
    - docker buildx create --driver docker-container --use || docker buildx use default
    - docker buildx build --build-arg NODE_VERSION=${NODE_VERSION} --build-arg VERSION=${VERSION} --push --provenance=true --sbom=true --platform linux/amd64,linux/arm64 -t ${DOCKER_REGISTRY}/${DOCKERHUB_REPOSITORY}:${VERSION} -t ${DOCKER_REGISTRY}/${DOCKERHUB_REPOSITORY}:latest -f docker/Dockerfile .

update dockerhub description:
  stage: docs
  image: peterevans/dockerhub-description:4
  interruptible: true
  rules:
    - if: '$CI_COMMIT_TAG == null && $CI_COMMIT_BRANCH == "main"'
      when: always
    - when: never
  cache: []
  before_script:
    - echo "${DOCKERHUB_PASSWORD}" | docker login -u "${DOCKERHUB_USERNAME}" --password-stdin "${DOCKER_REGISTRY}"
  script:
    - "--pipeline"
