stages:
  - init
  - test
  - build
  - release
  - docs

variables:
  DOCKER_REGISTRY: ${CI_REGISTRY}
  DOCKERHUB_PASSWORD: ${CI_REGISTRY_PASSWORD}
  DOCKERHUB_REPOSITORY: kirbownz/electrolux-to-mqtt
  DOCKERHUB_USERNAME: ${CI_REGISTRY_USERNAME}
  README_FILEPATH: ${CI_PROJECT_DIR}/README.md

initialise variables:
  stage: init
  image: alpine:latest
  interruptible: true
  rules:
    - if: '($CI_PIPELINE_SOURCE == "push" || $CI_PIPELINE_SOURCE == "web") && $CI_COMMIT_TAG == null'
      changes:
        - .gitlab-ci.yml
        - package.json
        - pnpm-lock.yaml
        - src/**/*
        - docker-compose*.yml
        - Dockerfile
        - entrypoint.sh
      when: always
    - when: never
  cache: []
  artifacts:
    reports:
      dotenv: variables.env
  script:
    - touch variables.env
    - echo "NODE_VERSION=$(cat .nvmrc)-alpine3.23" >> variables.env

bump version:
  stage: init
  image:
    name: registry.gitlab.com/go-semantic-release/semantic-release:latest
    entrypoint: [""]
  interruptible: true
  rules:
    - if: '($CI_PIPELINE_SOURCE == "push" || $CI_PIPELINE_SOURCE == "web") && $CI_COMMIT_TAG == null'
      changes:
        - .gitlab-ci.yml
        - package.json
        - pnpm-lock.yaml
        - src/**/*
        - docker-compose*.yml
        - Dockerfile
        - entrypoint.sh
      when: always
    - when: never
  cache: []
  artifacts:
    paths:
      - .version-unreleased
      - build.env
      - CHANGELOG
    expire_in: never
  script:
    - semantic-release --version-file --allow-no-changes --changelog CHANGELOG --dry
    - export VERSION=$(cat .version-unreleased)
    - echo "VERSION=${VERSION}" > build.env

install dependencies:
  stage: init
  image: node:${NODE_VERSION}
  interruptible: true
  rules:
    - if: '($CI_PIPELINE_SOURCE == "push" || $CI_PIPELINE_SOURCE == "web") && $CI_COMMIT_TAG == null'
      changes:
        - .gitlab-ci.yml
        - package.json
        - pnpm-lock.yaml
      when: always
    - when: never
  cache:
    key:
      files:
        - pnpm-lock.yaml
    paths:
      - .pnpm-store
      - node_modules
  needs:
    - job: initialise variables
      artifacts: true
  before_script:
    - echo "Node version from .nvmrc:" && cat .nvmrc
    - node --version
    - npm --version
    - export PACKAGE_MANAGER=$(node -p "require('./package.json').packageManager")
    - export PACKAGE_MANAGER_NAME=$(echo ${PACKAGE_MANAGER} | cut -d'@' -f1)
    - export PACKAGE_MANAGER_VERSION=$(echo ${PACKAGE_MANAGER} | cut -d'@' -f2)
    - echo "Package manager:" ${PACKAGE_MANAGER_NAME}@${PACKAGE_MANAGER_VERSION}
    - |
      if [ "${PACKAGE_MANAGER_NAME}" != "npm" ]; then
        echo "Installing package manager ${PACKAGE_MANAGER_NAME}@${PACKAGE_MANAGER_VERSION}"
        npm install -g --force ${PACKAGE_MANAGER_NAME}@${PACKAGE_MANAGER_VERSION}
      fi
    - |
      if [ "${PACKAGE_MANAGER_NAME}" = "pnpm" ]; then
        pnpm config set store-dir .pnpm-store
      fi
  script:
    - echo "Installing dependencies..."
    - ${PACKAGE_MANAGER_NAME} install --config.scripts-prepend-node-path=true

test:
  stage: test
  image: node:${NODE_VERSION}
  interruptible: true
  rules:
    - if: '($CI_PIPELINE_SOURCE == "push" || $CI_PIPELINE_SOURCE == "web") && $CI_COMMIT_TAG == null'
      changes:
        - .gitlab-ci.yml
        - package.json
        - pnpm-lock.yaml
        - src/**/*
        - tests/**/*
        - tsconfig.json
        - vitest.config.ts
      when: always
    - when: never
  cache:
    key:
      files:
        - pnpm-lock.yaml
    paths:
      - .pnpm-store
      - node_modules
  needs:
    - job: initialise variables
      artifacts: true
    - job: install dependencies
      artifacts: false
  coverage: '/All files\s+\|\s+[0-9.]+\s+\|\s+[0-9.]+\s+\|\s+[0-9.]+\s+\|\s+([0-9.]+)/'
  artifacts:
    reports:
      coverage_report:
        coverage_format: cobertura
        path: coverage/cobertura-coverage.xml
    paths:
      - coverage/
    expire_in: 1 week
  before_script:
    - echo "Running tests with coverage..."
    - export PACKAGE_MANAGER=$(node -p "require('./package.json').packageManager")
    - export PACKAGE_MANAGER_NAME=$(echo ${PACKAGE_MANAGER} | cut -d'@' -f1)
    - export PACKAGE_MANAGER_VERSION=$(echo ${PACKAGE_MANAGER} | cut -d'@' -f2)
    - |
      if [ "${PACKAGE_MANAGER_NAME}" != "npm" ]; then
        npm install -g --force ${PACKAGE_MANAGER_NAME}@${PACKAGE_MANAGER_VERSION}
      fi
    - |
      if [ "${PACKAGE_MANAGER_NAME}" = "pnpm" ]; then
        pnpm config set store-dir .pnpm-store
      fi
  script:
    - FORCE_COLOR=1 ${PACKAGE_MANAGER_NAME} test:coverage
  allow_failure: false

lint:
  stage: test
  image: node:${NODE_VERSION}
  interruptible: true
  rules:
    - if: '($CI_PIPELINE_SOURCE == "push" || $CI_PIPELINE_SOURCE == "web") && $CI_COMMIT_TAG == null'
      changes:
        - .gitlab-ci.yml
        - package.json
        - pnpm-lock.yaml
        - src/**/*
        - tests/**/*
        - biome.jsonc
      when: always
    - when: never
  cache:
    key:
      files:
        - pnpm-lock.yaml
    paths:
      - .pnpm-store
      - node_modules
  needs:
    - job: initialise variables
      artifacts: true
    - job: install dependencies
      artifacts: false
  before_script:
    - echo "Running linter checks..."
    - export PACKAGE_MANAGER=$(node -p "require('./package.json').packageManager")
    - export PACKAGE_MANAGER_NAME=$(echo ${PACKAGE_MANAGER} | cut -d'@' -f1)
    - export PACKAGE_MANAGER_VERSION=$(echo ${PACKAGE_MANAGER} | cut -d'@' -f2)
    - |
      if [ "${PACKAGE_MANAGER_NAME}" != "npm" ]; then
        npm install -g --force ${PACKAGE_MANAGER_NAME}@${PACKAGE_MANAGER_VERSION}
      fi
    - |
      if [ "${PACKAGE_MANAGER_NAME}" = "pnpm" ]; then
        pnpm config set store-dir .pnpm-store
      fi
  script:
    - ${PACKAGE_MANAGER_NAME} biome check .
  allow_failure: false

audit:
  stage: test
  image: node:${NODE_VERSION}
  interruptible: true
  rules:
    - if: '($CI_PIPELINE_SOURCE == "push" || $CI_PIPELINE_SOURCE == "web") && $CI_COMMIT_TAG == null'
      changes:
        - .gitlab-ci.yml
        - package.json
        - pnpm-lock.yaml
      when: always
    - when: never
  cache:
    key:
      files:
        - pnpm-lock.yaml
    paths:
      - .pnpm-store
      - node_modules
  needs:
    - job: initialise variables
      artifacts: true
    - job: install dependencies
      artifacts: false
  before_script:
    - echo "Running security audit..."
    - export PACKAGE_MANAGER=$(node -p "require('./package.json').packageManager")
    - export PACKAGE_MANAGER_NAME=$(echo ${PACKAGE_MANAGER} | cut -d'@' -f1)
    - export PACKAGE_MANAGER_VERSION=$(echo ${PACKAGE_MANAGER} | cut -d'@' -f2)
    - |
      if [ "${PACKAGE_MANAGER_NAME}" != "npm" ]; then
        npm install -g --force ${PACKAGE_MANAGER_NAME}@${PACKAGE_MANAGER_VERSION}
      fi
    - |
      if [ "${PACKAGE_MANAGER_NAME}" = "pnpm" ]; then
        pnpm config set store-dir .pnpm-store
      fi
  script:
    - ${PACKAGE_MANAGER_NAME} audit
  allow_failure: false

try to build docker images:
  stage: build
  image: docker:latest
  interruptible: true
  rules:
    - if: '($CI_PIPELINE_SOURCE == "push" || $CI_PIPELINE_SOURCE == "web") && $CI_COMMIT_TAG == null && $CI_COMMIT_BRANCH != "main"'
      changes:
        - .gitlab-ci.yml
        - package.json
        - pnpm-lock.yaml
        - src/**/*
        - docker-compose*.yml
        - Dockerfile
        - entrypoint.sh
      when: always
    - when: never
  cache: []
  needs:
    - job: initialise variables
      artifacts: true
    - job: bump version
      artifacts: true
  services:
    - docker:dind
  before_script:
    - apk add --no-cache qemu qemu-system-x86_64
  script:
    - source build.env
    - docker buildx create --use
    - docker buildx build --build-arg NODE_VERSION=${NODE_VERSION} --build-arg VERSION=${VERSION} --platform linux/amd64,linux/arm64 -t kirbownz/electrolux-to-mqtt:latest .

create gitlab release:
  stage: release
  image:
    name: registry.gitlab.com/go-semantic-release/semantic-release:latest
    entrypoint: [""]
  interruptible: true
  rules:
    - if: '($CI_PIPELINE_SOURCE == "push" || $CI_PIPELINE_SOURCE == "web") && $CI_COMMIT_TAG == null && $CI_COMMIT_BRANCH == "main"'
      changes:
        - .gitlab-ci.yml
        - package.json
        - pnpm-lock.yaml
        - src/**/*
        - docker-compose*.yml
        - Dockerfile
        - entrypoint.sh
      when: always
    - when: never
  cache: []
  needs:
    - job: initialise variables
      artifacts: false
    - job: bump version
      artifacts: true
  script:
    - semantic-release

build and deploy docker images:
  stage: release
  image: docker:latest
  interruptible: true
  rules:
    - if: '($CI_PIPELINE_SOURCE == "push" || $CI_PIPELINE_SOURCE == "web") && $CI_COMMIT_TAG == null && $CI_COMMIT_BRANCH == "main"'
      changes:
        - .gitlab-ci.yml
        - package.json
        - pnpm-lock.yaml
        - src/**/*
        - docker-compose*.yml
        - Dockerfile
        - entrypoint.sh
      when: always
    - when: never
  cache: []
  needs:
    - job: initialise variables
      artifacts: true
    - job: bump version
      artifacts: true
  services:
    - docker:dind
  before_script:
    - apk add --no-cache qemu qemu-system-x86_64
    - echo "${DOCKERHUB_PASSWORD}" | docker login -u "${DOCKERHUB_USERNAME}" --password-stdin "${DOCKER_REGISTRY}"
    - echo "${DOCKERHUB_PASSWORD}" | docker login -u "${DOCKERHUB_USERNAME}" --password-stdin dhi.io
  script:
    - source build.env
    - docker buildx create --use
    - docker buildx build --build-arg NODE_VERSION=${NODE_VERSION} --build-arg VERSION=${VERSION} --push --platform linux/amd64,linux/arm64 -t ${DOCKER_REGISTRY}/${DOCKERHUB_REPOSITORY}:${VERSION} -t ${DOCKER_REGISTRY}/${DOCKERHUB_REPOSITORY}:latest .

update dockerhub description:
  stage: docs
  image: peterevans/dockerhub-description:4
  interruptible: true
  rules:
    - if: '($CI_PIPELINE_SOURCE == "push" || $CI_PIPELINE_SOURCE == "web") && $CI_COMMIT_TAG == null && $CI_COMMIT_BRANCH == "main"'
      when: always
    - when: never
  cache: []
  before_script:
    - echo "${DOCKERHUB_PASSWORD}" | docker login -u "${DOCKERHUB_USERNAME}" --password-stdin "${DOCKER_REGISTRY}"
  script:
    - "--pipeline"
